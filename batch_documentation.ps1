# PowerShell script to automate XML documentation generation for C# files
# This script processes files without documentation, filtering out auto-generated files

param(
    [int]$MaxFiles = 50,  # Limit number of files to process in one run
    [string]$OutputLog = "documentation_log.txt"
)

Write-Host "Starting batch documentation process..." -ForegroundColor Green

# Function to check if file is auto-generated
function Test-AutoGeneratedFile {
    param([string]$FilePath)
    
    $fileName = [System.IO.Path]::GetFileName($FilePath)
    $directory = [System.IO.Path]::GetDirectoryName($FilePath)
    
    # Check for auto-generated file patterns
    $autoGeneratedPatterns = @(
        "obj\",
        "bin\",
        ".AssemblyInfo.cs",
        ".Designer.cs",
        ".g.cs",
        ".generated.cs",
        "AssemblyAttributes.cs",
        "GlobalAssemblyInfo.cs"
    )
    
    foreach ($pattern in $autoGeneratedPatterns) {
        if ($FilePath -like "*$pattern*" -or $fileName -like "*$pattern*") {
            return $true
        }
    }
    
    return $false
}

# Function to check if file already has documentation
function Test-HasDocumentation {
    param([string]$FilePath)
    
    try {
        $content = Get-Content $FilePath -Raw -ErrorAction Stop
        return $content -match "/// <summary>"
    }
    catch {
        Write-Warning "Could not read file: $FilePath"
        return $true  # Assume it has documentation to skip it
    }
}

# Get files without documentation
$filesWithoutDoc = @()
$allFiles = Get-ChildItem -Path "Kontecg/src" -Recurse -Filter "*.cs" -ErrorAction SilentlyContinue
$allFiles += Get-ChildItem -Path "Kontecg.SGNOM/src" -Recurse -Filter "*.cs" -ErrorAction SilentlyContinue

Write-Host "Analyzing $($allFiles.Count) C# files..." -ForegroundColor Yellow

foreach ($file in $allFiles) {
    if (-not (Test-AutoGeneratedFile -FilePath $file.FullName) -and -not (Test-HasDocumentation -FilePath $file.FullName)) {
        $filesWithoutDoc += $file
    }
}

Write-Host "Found $($filesWithoutDoc.Count) files requiring documentation (excluding auto-generated files)" -ForegroundColor Cyan

# Process files in batches
$processedCount = 0
$logEntries = @()

foreach ($file in $filesWithoutDoc) {
    if ($processedCount -ge $MaxFiles) {
        Write-Host "Reached maximum file limit ($MaxFiles). Stopping." -ForegroundColor Yellow
        break
    }
    
    try {
        Write-Host "Processing: $($file.Name)" -ForegroundColor White
        
        # Read file content
        $content = Get-Content $file.FullName -Raw -ErrorAction Stop
        
        # Basic documentation template (this would be enhanced with actual parsing)
        $documentedContent = $content -replace 'public class (\w+)', "/// <summary>`n/// Represents a $1 class.`n/// </summary>`n/// <remarks>`n/// This class provides functionality for $1 operations.`n/// </remarks>`npublic class `$1"
        
        # Write back to file
        Set-Content -Path $file.FullName -Value $documentedContent -Encoding UTF8
        
        $processedCount++
        $logEntries += "SUCCESS: $($file.FullName)"
        
        Write-Host "  ✓ Documented" -ForegroundColor Green
    }
    catch {
        $errorMsg = "ERROR: $($file.FullName) - $($_.Exception.Message)"
        $logEntries += $errorMsg
        Write-Host "  ✗ Error: $($_.Exception.Message)" -ForegroundColor Red
    }
}

# Write log
$logEntries | Out-File -FilePath $OutputLog -Encoding UTF8

Write-Host "`nBatch documentation completed!" -ForegroundColor Green
Write-Host "Processed: $processedCount files" -ForegroundColor Cyan
Write-Host "Log saved to: $OutputLog" -ForegroundColor Cyan
Write-Host "Remaining files: $($filesWithoutDoc.Count - $processedCount)" -ForegroundColor Yellow 